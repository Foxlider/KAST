@page "/mods"
@using KAST.Data.Models
@using KAST.Core.Services
@inject ModService ModService
@inject ISnackbar Snackbar

<PageTitle>Mods</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Mods</MudText>
<MudText Class="mb-8">Manage your Arma 3 mods from the database.</MudText>

@if (mods == null)
{
    <MudProgressCircular Color="MudBlazor.Color.Default" Indeterminate="true" />
}
else if (!mods.Any())
{
    <MudAlert Severity="Severity.Info">
        No mods found in the database. Add some mods to get started.
    </MudAlert>
    
    <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Add" 
               OnClick="AddSampleMod" Class="mt-4">
        Add Sample Mod
    </MudButton>
}
else
{
    <MudTable Items="mods" Hover="true" FixedHeader="true" SortLabel="Sort By" Elevation="0">
        <ColGroup>
            <col style="width: 5%;" />
            <col style="width: 15%;" />
            <col />
            <col style="width: 15%;" />
            <col style="width: 10%;" />
            <col style="width: 10%;" />
            <col style="width: 15%;" />
        </ColGroup>
        <HeaderContent>
            <MudTh><MudTableSortLabel SortBy="new Func<Mod, object>(x=>x.IsLocal)">Type</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel InitialDirection="SortDirection.Ascending" SortBy="new Func<Mod, object>(x=>x.SteamId ?? string.Empty)">Steam ID</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel SortBy="new Func<Mod, object>(x=>x.Name)">Name</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel SortBy="new Func<Mod, object>(x=>x.Author ?? string.Empty)">Author</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel SortBy="new Func<Mod, object>(x=>x.IsEnabled)">Enabled</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel SortBy="new Func<Mod, object>(x=>x.SizeBytes)">Size</MudTableSortLabel></MudTh>
            <MudTh>Actions</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="Type">
                @if (context.IsLocal)
                {
                    <MudIcon Icon="@Icons.Material.Filled.Folder" Title="Local Mod" />
                }
                else
                {
                    <MudIcon Icon="@Icons.Custom.Brands.Steam" Title="Steam Workshop Mod" />
                }
            </MudTd>
            <MudTd DataLabel="Steam ID">@(context.SteamId ?? "N/A")</MudTd>
            <MudTd DataLabel="Name">@context.Name</MudTd>
            <MudTd DataLabel="Author">@(context.Author ?? "Unknown")</MudTd>
            <MudTd DataLabel="Enabled">
                @if (context.IsEnabled)
                {
                    <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Color="Color.Success" />
                }
                else
                {
                    <MudIcon Icon="@Icons.Material.Filled.Cancel" Color="Color.Error" />
                }
            </MudTd>
            <MudTd DataLabel="Size">@FormatBytes(context.SizeBytes)</MudTd>
            <MudTd>
                <MudButtonGroup Variant="Variant.Outlined" Color="MudBlazor.Color.Primary">
                    <MudButton Size="Size.Small" StartIcon="@Icons.Material.Filled.Edit">
                        Edit
                    </MudButton>
                    <MudButton Size="Size.Small" StartIcon="@Icons.Material.Filled.Delete" 
                               Color="Color.Error" OnClick="() => DeleteMod(context.Id)">
                        Delete
                    </MudButton>
                </MudButtonGroup>
            </MudTd>
        </RowTemplate>
        <PagerContent>
            <MudTablePager PageSizeOptions="new int[]{50, 100}" />
        </PagerContent>
    </MudTable>
    
    <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Add" 
               OnClick="AddSampleMod" Class="mt-4">
        Add Sample Mod
    </MudButton>
}


@code {
    private List<Mod>? mods;

    protected override async Task OnInitializedAsync()
    {
        await LoadMods();
    }

    private async Task LoadMods()
    {
        try
        {
            mods = await ModService.GetAllModsAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading mods: {ex.Message}", Severity.Error);
        }
    }

    private async Task AddSampleMod()
    {
        try
        {
            var sampleMod = new Mod
            {
                Id = Guid.NewGuid(),
                Name = $"Sample Mod {DateTime.Now:HH:mm:ss}",
                Author = "KAST Team",
                Path = "/sample/path",
                SteamId = Random.Shared.Next(100000, 999999).ToString(),
                IsLocal = Random.Shared.NextDouble() > 0.5,
                SizeBytes = Random.Shared.NextInt64(1024 * 1024, 1024 * 1024 * 500), // 1MB to 500MB
                IsEnabled = true,
                Version = "1.0.0",
                CreatedAt = DateTime.UtcNow
            };

            await ModService.SaveModAsync(sampleMod);
            await LoadMods();
            Snackbar.Add("Sample mod added successfully!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error adding sample mod: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteMod(Guid modId)
    {
        try
        {
            if (await ModService.DeleteModAsync(modId))
            {
                await LoadMods();
                Snackbar.Add("Mod deleted successfully!", Severity.Success);
            }
            else
            {
                Snackbar.Add("Failed to delete mod.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error deleting mod: {ex.Message}", Severity.Error);
        }
    }

    private static string FormatBytes(long bytes)
    {
        if (bytes == 0) return "0 B";
        
        string[] suffixes = { "B", "KB", "MB", "GB", "TB" };
        int counter = 0;
        decimal number = bytes;
        
        while (Math.Round(number / 1024) >= 1)
        {
            number /= 1024;
            counter++;
        }
        
        return $"{number:n1} {suffixes[counter]}";
    }
}